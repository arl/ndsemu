package main

import (
	"ndsemu/emu/hwio"
	log "ndsemu/emu/logger"
)

var modSpi = log.NewModule("spi")

type SpiStatus int

const (
	SpiFinish SpiStatus = iota
	SpiContinue
)

type SpiDevice interface {
	// Begin a SPI transfer. This is called when the master
	// (the ARM cpu) beings a SPI transfer with the device
	// by triggering the CS line.
	// This can be used to clean up internal data structures
	// and prepare for the transfer.
	SpiBegin()

	// Execute the SPI transfer logic. This function is called
	// any time the ARM CPU writes a new full-byte to the SPI,
	// and must return the reply generated by the device.
	//
	// This interface aims to provide support for master/slave
	// protocols, where the master (CPU) sends a "request",
	// and the slave (the device) sends back a "reply". Both
	// requests and replies can be made of multiple bytes,
	// so we provide support for this.
	//
	// The data slice is the current request. When the transfer
	// begins, this is made by just one byte (the first being
	// written). SpiTransfer() must process it and return:
	//
	//  * optionally, a slice containing a reply. The reply can
	//    be one or multiple bytes, that are sent back to the
	//    ARM CPU in the specified order. If reply is nil,
	//    0s are sent back.
	//
	//  * a request status that signals whether the current request
	//    is finished (SpiFinish), or it is still being processed
	//    (SpiContinue). If it's still being processed, the next
	//    byte written by the CPU will be appended to the current
	//    request, and SpiTransfer() will be called with a longer
	//    slice representing the full request.
	//
	// The stat return value can thus be used by the SpiDevice to
	// manage multi-byte requests; until a request is complete,
	// SpiTransfer can return SpiContinue, and in any subsequent
	// call SpiTransfer will see the full request being formed
	// (with a growing request slice at each call). While the
	// request is forming, there is probably no reply, so "nil"
	// can be returned as reply (and zeroes will be transferred).
	//
	// When the request is finished, the SpiDevice can build the
	// reply and return it. The reply will be cached and sends
	// back the CPU one byte at a time. Notice that SpiTransfer
	// is *NOT* called while a multi-byte reply is being sent;
	// writes from the CPU are basically ignored.
	//
	//
	// Important note on the SPI protocol design
	//
	// The SPI bus has a particular design: for each written
	// byte from the master, a byte is always read back from the
	// device. The two transfers (write and read) happen
	// simultaneously (bit by bit), so, barring out weird bit-level
	// protocols, the read-during-the-write cannot be a reply to
	// the write itself. At the register level, this is simplified
	// like so: the CPU first writes the byte to the SpiData reg;
	// the hardware then triggers the transfer; when the transfer
	// is finished, the CPU reads back from SpiData the
	// byte that was read during the transfer.
	// Now, many protocols are normal master/slave protocols:
	// the CPU write a command (eg: "read status"), and the device
	// replies (eg: "my status is 0x12"). To keep the logic of
	// SpiTransfer() easier to implement, the replied value is
	// delayed by one byte: for instance, if
	// the device generates a reply for the first byte (data[0]),
	// reply[0] is sent to the ARM CPU only after (= while) data[1]
	// is being written.
	SpiTransfer(request []byte) (reply []byte, stat SpiStatus)

	// End a SPI transfer. This is called when the SPI transfer
	// is finished, that is, when the CS line goes low. This can
	// be used to clean up internal structures, flushing for
	// partial state.
	SpiEnd()
}

type HwSpiBus struct {
	devs  [4]SpiDevice
	tdev  SpiDevice
	req   []byte
	reply []byte

	SpiCnt  hwio.Reg16 `hwio:"offset=0x0,rwmask=0xCF03,wcb"`
	SpiData hwio.Reg8  `hwio:"offset=0x2,wcb"`
	Dummy   hwio.Reg8  `hwio:"offset=0x3,rwmask=0"` // disable logging
}

func NewHwSpiBus() *HwSpiBus {
	spi := new(HwSpiBus)
	spi.req = make([]byte, 0, 16)
	hwio.MustInitRegs(spi)
	return spi
}

func (spi *HwSpiBus) AddDevice(addr int, dev SpiDevice) {
	if spi.devs[addr] != nil {
		panic("spi: address already assigned")
	}
	spi.devs[addr] = dev
}

func (spi *HwSpiBus) WriteSPICNT(_, val uint16) {
	// log.Infof("control=%04x (%04x)", spi.control, val)

	if spi.SpiCnt.Value&(1<<15) != 0 {
		// Begin transfer
		didx := (spi.SpiCnt.Value >> 8) & 3
		if spi.tdev != nil {
			if spi.tdev != spi.devs[didx] {
				modSpi.Warnf("wrong new device=%d", didx)
				// panic("SPI changed device during transfer")
			} else {
				return
			}
		}
		spi.tdev = spi.devs[didx]
		if spi.tdev == nil {
			modSpi.Fatalf("SPI device %d not implemented", didx)
		}
		modSpi.Infof("begin transfer device=%d (%T)", didx, spi.tdev)
		spi.tdev.SpiBegin()
		spi.req = spi.req[:0]
		spi.reply = nil

		if spi.SpiCnt.Value&(1<<14) != 0 {
			panic("SPI IRQ not implemented")
		}
	}
}

func (spi *HwSpiBus) WriteSPIDATA(_, val uint8) {
	if spi.tdev == nil {
		modSpi.Warn("SPIDATA written but no transfer")
		return
	}

	// First, see if there's a pending reply. If so,
	// make the first byte available to the CPU by
	// putting it into the hw register SpiData.
	if len(spi.reply) == 0 {
		spi.SpiData.Value = 0
	} else {
		spi.SpiData.Value = spi.reply[0]
		spi.reply = spi.reply[1:]
	}

	// If the current reply was fully sent-out,
	// send the request to the device, as it's
	// possibly a new request to be processed.
	if len(spi.reply) == 0 {
		spi.req = append(spi.req, val)
		retval, stat := spi.tdev.SpiTransfer(spi.req)
		if stat == SpiFinish {
			spi.req = spi.req[:0]
		}
		spi.reply = retval
	}

	// Bit 11 is the "auto-reselect CS line". When 1, the CS
	// line is kept high at the end of the current byte transfer,
	// so basically the transfer continue. When 0, the CS line
	// goes down after the current byte is written.
	if spi.SpiCnt.Value&(1<<11) == 0 {
		spi.tdev.SpiEnd()
		spi.tdev = nil
		modSpi.Info("end of transfer")
		return
	}
}
