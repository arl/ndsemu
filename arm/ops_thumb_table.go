// Generated on 2015-12-17 00:13:21.030303772 +0100 CET
package arm

var opThumbTable = [256]func(*Cpu, uint16){
	(*Cpu).opThumb00,
	(*Cpu).opThumb01,
	(*Cpu).opThumb02,
	(*Cpu).opThumb03,
	(*Cpu).opThumb04,
	(*Cpu).opThumb05,
	(*Cpu).opThumb06,
	(*Cpu).opThumb07,
	(*Cpu).opThumb08,
	(*Cpu).opThumb09,
	(*Cpu).opThumb0A,
	(*Cpu).opThumb0B,
	(*Cpu).opThumb0C,
	(*Cpu).opThumb0D,
	(*Cpu).opThumb0E,
	(*Cpu).opThumb0F,
	(*Cpu).opThumb10,
	(*Cpu).opThumb11,
	(*Cpu).opThumb12,
	(*Cpu).opThumb13,
	(*Cpu).opThumb14,
	(*Cpu).opThumb15,
	(*Cpu).opThumb16,
	(*Cpu).opThumb17,
	(*Cpu).opThumb18,
	(*Cpu).opThumb19,
	(*Cpu).opThumb1A,
	(*Cpu).opThumb1B,
	(*Cpu).opThumb1C,
	(*Cpu).opThumb1D,
	(*Cpu).opThumb1E,
	(*Cpu).opThumb1F,
	(*Cpu).opThumb20,
	(*Cpu).opThumb21,
	(*Cpu).opThumb22,
	(*Cpu).opThumb23,
	(*Cpu).opThumb24,
	(*Cpu).opThumb25,
	(*Cpu).opThumb26,
	(*Cpu).opThumb27,
	(*Cpu).opThumb28,
	(*Cpu).opThumb29,
	(*Cpu).opThumb2A,
	(*Cpu).opThumb2B,
	(*Cpu).opThumb2C,
	(*Cpu).opThumb2D,
	(*Cpu).opThumb2E,
	(*Cpu).opThumb2F,
	(*Cpu).opThumb30,
	(*Cpu).opThumb31,
	(*Cpu).opThumb32,
	(*Cpu).opThumb33,
	(*Cpu).opThumb34,
	(*Cpu).opThumb35,
	(*Cpu).opThumb36,
	(*Cpu).opThumb37,
	(*Cpu).opThumb38,
	(*Cpu).opThumb39,
	(*Cpu).opThumb3A,
	(*Cpu).opThumb3B,
	(*Cpu).opThumb3C,
	(*Cpu).opThumb3D,
	(*Cpu).opThumb3E,
	(*Cpu).opThumb3F,
	(*Cpu).opThumb40,
	(*Cpu).opThumb41,
	(*Cpu).opThumb42,
	(*Cpu).opThumb43,
	(*Cpu).opThumb44,
	(*Cpu).opThumb45,
	(*Cpu).opThumb46,
	(*Cpu).opThumb47,
	(*Cpu).opThumb48,
	(*Cpu).opThumb49,
	(*Cpu).opThumb4A,
	(*Cpu).opThumb4B,
	(*Cpu).opThumb4C,
	(*Cpu).opThumb4D,
	(*Cpu).opThumb4E,
	(*Cpu).opThumb4F,
	(*Cpu).opThumb50,
	(*Cpu).opThumb51,
	(*Cpu).opThumb52,
	(*Cpu).opThumb53,
	(*Cpu).opThumb54,
	(*Cpu).opThumb55,
	(*Cpu).opThumb56,
	(*Cpu).opThumb57,
	(*Cpu).opThumb58,
	(*Cpu).opThumb59,
	(*Cpu).opThumb5A,
	(*Cpu).opThumb5B,
	(*Cpu).opThumb5C,
	(*Cpu).opThumb5D,
	(*Cpu).opThumb5E,
	(*Cpu).opThumb5F,
	(*Cpu).opThumb60,
	(*Cpu).opThumb61,
	(*Cpu).opThumb62,
	(*Cpu).opThumb63,
	(*Cpu).opThumb64,
	(*Cpu).opThumb65,
	(*Cpu).opThumb66,
	(*Cpu).opThumb67,
	(*Cpu).opThumb68,
	(*Cpu).opThumb69,
	(*Cpu).opThumb6A,
	(*Cpu).opThumb6B,
	(*Cpu).opThumb6C,
	(*Cpu).opThumb6D,
	(*Cpu).opThumb6E,
	(*Cpu).opThumb6F,
	(*Cpu).opThumb70,
	(*Cpu).opThumb71,
	(*Cpu).opThumb72,
	(*Cpu).opThumb73,
	(*Cpu).opThumb74,
	(*Cpu).opThumb75,
	(*Cpu).opThumb76,
	(*Cpu).opThumb77,
	(*Cpu).opThumb78,
	(*Cpu).opThumb79,
	(*Cpu).opThumb7A,
	(*Cpu).opThumb7B,
	(*Cpu).opThumb7C,
	(*Cpu).opThumb7D,
	(*Cpu).opThumb7E,
	(*Cpu).opThumb7F,
	(*Cpu).opThumb80,
	(*Cpu).opThumb81,
	(*Cpu).opThumb82,
	(*Cpu).opThumb83,
	(*Cpu).opThumb84,
	(*Cpu).opThumb85,
	(*Cpu).opThumb86,
	(*Cpu).opThumb87,
	(*Cpu).opThumb88,
	(*Cpu).opThumb89,
	(*Cpu).opThumb8A,
	(*Cpu).opThumb8B,
	(*Cpu).opThumb8C,
	(*Cpu).opThumb8D,
	(*Cpu).opThumb8E,
	(*Cpu).opThumb8F,
	(*Cpu).opThumb90,
	(*Cpu).opThumb91,
	(*Cpu).opThumb92,
	(*Cpu).opThumb93,
	(*Cpu).opThumb94,
	(*Cpu).opThumb95,
	(*Cpu).opThumb96,
	(*Cpu).opThumb97,
	(*Cpu).opThumb98,
	(*Cpu).opThumb99,
	(*Cpu).opThumb9A,
	(*Cpu).opThumb9B,
	(*Cpu).opThumb9C,
	(*Cpu).opThumb9D,
	(*Cpu).opThumb9E,
	(*Cpu).opThumb9F,
	(*Cpu).opThumbA0,
	(*Cpu).opThumbA1,
	(*Cpu).opThumbA2,
	(*Cpu).opThumbA3,
	(*Cpu).opThumbA4,
	(*Cpu).opThumbA5,
	(*Cpu).opThumbA6,
	(*Cpu).opThumbA7,
	(*Cpu).opThumbA8,
	(*Cpu).opThumbA9,
	(*Cpu).opThumbAA,
	(*Cpu).opThumbAB,
	(*Cpu).opThumbAC,
	(*Cpu).opThumbAD,
	(*Cpu).opThumbAE,
	(*Cpu).opThumbAF,
	(*Cpu).opThumbB0,
	(*Cpu).opThumbB1,
	(*Cpu).opThumbB2,
	(*Cpu).opThumbB3,
	(*Cpu).opThumbB4,
	(*Cpu).opThumbB5,
	(*Cpu).opThumbB6,
	(*Cpu).opThumbB7,
	(*Cpu).opThumbB8,
	(*Cpu).opThumbB9,
	(*Cpu).opThumbBA,
	(*Cpu).opThumbBB,
	(*Cpu).opThumbBC,
	(*Cpu).opThumbBD,
	(*Cpu).opThumbBE,
	(*Cpu).opThumbBF,
	(*Cpu).opThumbC0,
	(*Cpu).opThumbC1,
	(*Cpu).opThumbC2,
	(*Cpu).opThumbC3,
	(*Cpu).opThumbC4,
	(*Cpu).opThumbC5,
	(*Cpu).opThumbC6,
	(*Cpu).opThumbC7,
	(*Cpu).opThumbC8,
	(*Cpu).opThumbC9,
	(*Cpu).opThumbCA,
	(*Cpu).opThumbCB,
	(*Cpu).opThumbCC,
	(*Cpu).opThumbCD,
	(*Cpu).opThumbCE,
	(*Cpu).opThumbCF,
	(*Cpu).opThumbD0,
	(*Cpu).opThumbD1,
	(*Cpu).opThumbD2,
	(*Cpu).opThumbD3,
	(*Cpu).opThumbD4,
	(*Cpu).opThumbD5,
	(*Cpu).opThumbD6,
	(*Cpu).opThumbD7,
	(*Cpu).opThumbD8,
	(*Cpu).opThumbD9,
	(*Cpu).opThumbDA,
	(*Cpu).opThumbDB,
	(*Cpu).opThumbDC,
	(*Cpu).opThumbDD,
	(*Cpu).opThumbDE,
	(*Cpu).opThumbDF,
	(*Cpu).opThumbE0,
	(*Cpu).opThumbE1,
	(*Cpu).opThumbE2,
	(*Cpu).opThumbE3,
	(*Cpu).opThumbE4,
	(*Cpu).opThumbE5,
	(*Cpu).opThumbE6,
	(*Cpu).opThumbE7,
	(*Cpu).opThumbE8,
	(*Cpu).opThumbE9,
	(*Cpu).opThumbEA,
	(*Cpu).opThumbEB,
	(*Cpu).opThumbEC,
	(*Cpu).opThumbED,
	(*Cpu).opThumbEE,
	(*Cpu).opThumbEF,
	(*Cpu).opThumbF0,
	(*Cpu).opThumbF1,
	(*Cpu).opThumbF2,
	(*Cpu).opThumbF3,
	(*Cpu).opThumbF4,
	(*Cpu).opThumbF5,
	(*Cpu).opThumbF6,
	(*Cpu).opThumbF7,
	(*Cpu).opThumbF8,
	(*Cpu).opThumbF9,
	(*Cpu).opThumbFA,
	(*Cpu).opThumbFB,
	(*Cpu).opThumbFC,
	(*Cpu).opThumbFD,
	(*Cpu).opThumbFE,
	(*Cpu).opThumbFF,
}
var opThumbAluTable = [16]func(*Cpu, uint16){
	(*Cpu).opThumbAlu00,
	(*Cpu).opThumbAlu01,
	(*Cpu).opThumbAlu02,
	(*Cpu).opThumbAlu03,
	(*Cpu).opThumbAlu04,
	(*Cpu).opThumbAlu05,
	(*Cpu).opThumbAlu06,
	(*Cpu).opThumbAlu07,
	(*Cpu).opThumbAlu08,
	(*Cpu).opThumbAlu09,
	(*Cpu).opThumbAlu0A,
	(*Cpu).opThumbAlu0B,
	(*Cpu).opThumbAlu0C,
	(*Cpu).opThumbAlu0D,
	(*Cpu).opThumbAlu0E,
	(*Cpu).opThumbAlu0F,
}

func (cpu *Cpu) opThumb00(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb01(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb02(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb03(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb04(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb05(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb06(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb07(op uint16) {
	// LSL
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset != 0 {
		cpu.Cpsr.SetC(rs&(1<<(32-offset)) != 0)
	}
	res := rs << offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb08(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb09(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb0A(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb0B(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb0C(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb0D(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb0E(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb0F(op uint16) {
	// LSR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := rs >> offset
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb10(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb11(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb12(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb13(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb14(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb15(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb16(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb17(op uint16) {
	// ASR
	rsx := (op >> 3) & 7
	rdx := op & 7
	offset := (op >> 6) & 0x1F
	rs := uint32(cpu.Regs[rsx])
	if offset == 0 {
		offset = 32
	}
	cpu.Cpsr.SetC(rs&(1<<(offset-1)) != 0)
	res := uint32(int32(rs) >> offset)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb18(op uint16) {
	// ADD
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	rnx := (op >> 6) & 7
	val := uint32(cpu.Regs[rnx])
	res := rs + val
	cpu.Cpsr.SetC(res < rs)
	cpu.Cpsr.SetVAdd(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb19(op uint16) {
	// ADD
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	rnx := (op >> 6) & 7
	val := uint32(cpu.Regs[rnx])
	res := rs + val
	cpu.Cpsr.SetC(res < rs)
	cpu.Cpsr.SetVAdd(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb1A(op uint16) {
	// SUB
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	rnx := (op >> 6) & 7
	val := uint32(cpu.Regs[rnx])
	res := rs - val
	cpu.Cpsr.SetC(res <= rs)
	cpu.Cpsr.SetVSub(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb1B(op uint16) {
	// SUB
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	rnx := (op >> 6) & 7
	val := uint32(cpu.Regs[rnx])
	res := rs - val
	cpu.Cpsr.SetC(res <= rs)
	cpu.Cpsr.SetVSub(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb1C(op uint16) {
	// ADD #nn
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	val := uint32((op >> 6) & 7)
	res := rs + val
	cpu.Cpsr.SetC(res < rs)
	cpu.Cpsr.SetVAdd(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb1D(op uint16) {
	// ADD #nn
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	val := uint32((op >> 6) & 7)
	res := rs + val
	cpu.Cpsr.SetC(res < rs)
	cpu.Cpsr.SetVAdd(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb1E(op uint16) {
	// SUB #nn
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	val := uint32((op >> 6) & 7)
	res := rs - val
	cpu.Cpsr.SetC(res <= rs)
	cpu.Cpsr.SetVSub(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb1F(op uint16) {
	// SUB #nn
	rsx := (op >> 3) & 7
	rdx := op & 7
	rs := uint32(cpu.Regs[rsx])
	val := uint32((op >> 6) & 7)
	res := rs - val
	cpu.Cpsr.SetC(res <= rs)
	cpu.Cpsr.SetVSub(rs, val, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumb20(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[0] = reg(res)
}

func (cpu *Cpu) opThumb21(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[1] = reg(res)
}

func (cpu *Cpu) opThumb22(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[2] = reg(res)
}

func (cpu *Cpu) opThumb23(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[3] = reg(res)
}

func (cpu *Cpu) opThumb24(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[4] = reg(res)
}

func (cpu *Cpu) opThumb25(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[5] = reg(res)
}

func (cpu *Cpu) opThumb26(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[6] = reg(res)
}

func (cpu *Cpu) opThumb27(op uint16) {
	// MOV
	imm := uint32(op & 0xFF)
	res := imm
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[7] = reg(res)
}

func (cpu *Cpu) opThumb28(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[0])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb29(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[1])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb2A(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[2])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb2B(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[3])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb2C(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[4])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb2D(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[5])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb2E(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[6])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb2F(op uint16) {
	// CMP
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[7])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumb30(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[0])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[0] = reg(res)
}

func (cpu *Cpu) opThumb31(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[1])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[1] = reg(res)
}

func (cpu *Cpu) opThumb32(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[2])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[2] = reg(res)
}

func (cpu *Cpu) opThumb33(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[3])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[3] = reg(res)
}

func (cpu *Cpu) opThumb34(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[4])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[4] = reg(res)
}

func (cpu *Cpu) opThumb35(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[5])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[5] = reg(res)
}

func (cpu *Cpu) opThumb36(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[6])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[6] = reg(res)
}

func (cpu *Cpu) opThumb37(op uint16) {
	// ADD
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[7])
	res := rd + imm
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[7] = reg(res)
}

func (cpu *Cpu) opThumb38(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[0])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[0] = reg(res)
}

func (cpu *Cpu) opThumb39(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[1])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[1] = reg(res)
}

func (cpu *Cpu) opThumb3A(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[2])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[2] = reg(res)
}

func (cpu *Cpu) opThumb3B(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[3])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[3] = reg(res)
}

func (cpu *Cpu) opThumb3C(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[4])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[4] = reg(res)
}

func (cpu *Cpu) opThumb3D(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[5])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[5] = reg(res)
}

func (cpu *Cpu) opThumb3E(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[6])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[6] = reg(res)
}

func (cpu *Cpu) opThumb3F(op uint16) {
	// SUB
	imm := uint32(op & 0xFF)
	rd := uint32(cpu.Regs[7])
	res := rd - imm
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, imm, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[7] = reg(res)
}

func (cpu *Cpu) opThumb40(op uint16) {
	opThumbAluTable[(op>>6)&0xF](cpu, op)
}

func (cpu *Cpu) opThumb41(op uint16) {
	opThumbAluTable[(op>>6)&0xF](cpu, op)
}

func (cpu *Cpu) opThumb42(op uint16) {
	opThumbAluTable[(op>>6)&0xF](cpu, op)
}

func (cpu *Cpu) opThumb43(op uint16) {
	opThumbAluTable[(op>>6)&0xF](cpu, op)
}

func (cpu *Cpu) opThumb44(op uint16) {
	// ADD(h)
	rdx := (op & 7) | (op&0x80)>>4
	rsx := ((op >> 3) & 0xF)
	rs := uint32(cpu.Regs[rsx])
	rd := uint32(cpu.Regs[rdx])
	cpu.Regs[rdx] = reg(rd + rs)
	if rdx == 15 {
		cpu.pc = cpu.Regs[15] &^ 1
	}
}

func (cpu *Cpu) opThumb45(op uint16) {
	// CMP(h)
	rdx := (op & 7) | (op&0x80)>>4
	rsx := ((op >> 3) & 0xF)
	rs := uint32(cpu.Regs[rsx])
	rd := uint32(cpu.Regs[rdx])
	res := rd - rs
	cpu.Cpsr.SetNZ(res)
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, rs, res)
}

func (cpu *Cpu) opThumb46(op uint16) {
	// MOV(h)
	rdx := (op & 7) | (op&0x80)>>4
	rsx := ((op >> 3) & 0xF)
	rs := uint32(cpu.Regs[rsx])
	cpu.Regs[rdx] = reg(rs)
	if rdx == 15 {
		cpu.pc = reg(rs) &^ 1
	}
}

func (cpu *Cpu) opThumb47(op uint16) {
	// BX/BLX
	rdx := (op & 7) | (op&0x80)>>4
	rsx := ((op >> 3) & 0xF)
	rs := uint32(cpu.Regs[rsx])
	if op&0x80 != 0 {
		cpu.Regs[14] = cpu.Regs[15] + 1
	}
	cpu.pc = reg(rs) &^ 1
	if rs&1 == 0 {
		cpu.Cpsr.SetT(false)
		cpu.pc &^= 3
	}
	_ = rdx
}

func (cpu *Cpu) opThumb48(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[0] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb49(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[1] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb4A(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[2] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb4B(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[3] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb4C(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[4] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb4D(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[5] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb4E(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[6] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb4F(op uint16) {
	// LDR PC
	pc := uint32(cpu.Regs[15]) &^ 2
	pc += uint32((op & 0xFF) * 4)
	cpu.Regs[7] = reg(cpu.opRead32(pc))
}

func (cpu *Cpu) opThumb50(op uint16) {
	// STR
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.opWrite32(addr, uint32(cpu.Regs[rdx]))
}

func (cpu *Cpu) opThumb51(op uint16) {
	// STR
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.opWrite32(addr, uint32(cpu.Regs[rdx]))
}

func (cpu *Cpu) opThumb52(op uint16) {
	// STRH
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.opWrite16(addr, uint16(cpu.Regs[rdx]))
}

func (cpu *Cpu) opThumb53(op uint16) {
	// STRH
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.opWrite16(addr, uint16(cpu.Regs[rdx]))
}

func (cpu *Cpu) opThumb54(op uint16) {
	// STRB
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.opWrite8(addr, uint8(cpu.Regs[rdx]))
}

func (cpu *Cpu) opThumb55(op uint16) {
	// STRB
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.opWrite8(addr, uint8(cpu.Regs[rdx]))
}

func (cpu *Cpu) opThumb56(op uint16) {
	// LDSB
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(int8(cpu.opRead8(addr)))
}

func (cpu *Cpu) opThumb57(op uint16) {
	// LDSB
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(int8(cpu.opRead8(addr)))
}

func (cpu *Cpu) opThumb58(op uint16) {
	// LDR
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(cpu.opRead32(addr))
}

func (cpu *Cpu) opThumb59(op uint16) {
	// LDR
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(cpu.opRead32(addr))
}

func (cpu *Cpu) opThumb5A(op uint16) {
	// LDRH
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(cpu.opRead16(addr))
}

func (cpu *Cpu) opThumb5B(op uint16) {
	// LDRH
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(cpu.opRead16(addr))
}

func (cpu *Cpu) opThumb5C(op uint16) {
	// LDRB
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(cpu.opRead8(addr))
}

func (cpu *Cpu) opThumb5D(op uint16) {
	// LDRB
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(cpu.opRead8(addr))
}

func (cpu *Cpu) opThumb5E(op uint16) {
	// LDSH
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(int16(cpu.opRead16(addr)))
}

func (cpu *Cpu) opThumb5F(op uint16) {
	// LDSH
	rox := (op >> 6) & 7
	rbx := (op >> 3) & 7
	rdx := op & 7
	addr := uint32(cpu.Regs[rbx] + cpu.Regs[rox])
	cpu.Regs[rdx] = reg(int16(cpu.opRead16(addr)))
}

func (cpu *Cpu) opThumb60(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb61(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb62(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb63(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb64(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb65(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb66(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb67(op uint16) {
	// STR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	rd := uint32(cpu.Regs[rdx])
	cpu.opWrite32(rb+offset, rd)
}

func (cpu *Cpu) opThumb68(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb69(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb6A(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb6B(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb6C(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb6D(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb6E(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb6F(op uint16) {
	// LDR #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 4
	cpu.Regs[rdx] = reg(cpu.opRead32(rb + offset))
}

func (cpu *Cpu) opThumb70(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb71(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb72(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb73(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb74(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb75(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb76(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb77(op uint16) {
	// STRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	rd := uint8(cpu.Regs[rdx])
	cpu.opWrite8(rb+offset, rd)
}

func (cpu *Cpu) opThumb78(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb79(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb7A(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb7B(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb7C(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb7D(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb7E(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb7F(op uint16) {
	// LDRB #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	cpu.Regs[rdx] = reg(cpu.opRead8(rb + offset))
}

func (cpu *Cpu) opThumb80(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb81(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb82(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb83(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb84(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb85(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb86(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb87(op uint16) {
	// STRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	rd := uint16(cpu.Regs[rdx])
	cpu.opWrite16(rb+offset, rd)
}

func (cpu *Cpu) opThumb88(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb89(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb8A(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb8B(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb8C(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb8D(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb8E(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb8F(op uint16) {
	// LDRH #nn
	offset := uint32((op >> 6) & 0x1F)
	rbx := (op >> 3) & 0x7
	rdx := op & 0x7
	rb := uint32(cpu.Regs[rbx])
	offset *= 2
	cpu.Regs[rdx] = reg(cpu.opRead16(rb + offset))
}

func (cpu *Cpu) opThumb90(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[0]))
}

func (cpu *Cpu) opThumb91(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[1]))
}

func (cpu *Cpu) opThumb92(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[2]))
}

func (cpu *Cpu) opThumb93(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[3]))
}

func (cpu *Cpu) opThumb94(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[4]))
}

func (cpu *Cpu) opThumb95(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[5]))
}

func (cpu *Cpu) opThumb96(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[6]))
}

func (cpu *Cpu) opThumb97(op uint16) {
	// STR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.opWrite32(sp+uint32(offset), uint32(cpu.Regs[7]))
}

func (cpu *Cpu) opThumb98(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[0] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumb99(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[1] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumb9A(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[2] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumb9B(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[3] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumb9C(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[4] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumb9D(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[5] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumb9E(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[6] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumb9F(op uint16) {
	// LDR [SP+nn]
	offset := (op & 0xFF) * 4
	sp := uint32(cpu.Regs[13])
	cpu.Regs[7] = reg(cpu.opRead32(sp + uint32(offset)))
}

func (cpu *Cpu) opThumbA0(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[0] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA1(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[1] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA2(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[2] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA3(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[3] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA4(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[4] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA5(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[5] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA6(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[6] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA7(op uint16) {
	// ADD PC
	offset := (op & 0xFF) * 4
	cpu.Regs[7] = (cpu.Regs[15] &^ 2) + reg(offset)
}

func (cpu *Cpu) opThumbA8(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[0] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbA9(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[1] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbAA(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[2] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbAB(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[3] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbAC(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[4] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbAD(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[5] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbAE(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[6] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbAF(op uint16) {
	// ADD SP
	offset := (op & 0xFF) * 4
	cpu.Regs[7] = cpu.Regs[13] + reg(offset)
}

func (cpu *Cpu) opThumbB0(op uint16) {
	// ADD SP
	offset := (op & 0x7F) * 4
	if op&0x80 == 0 {
		cpu.Regs[13] += reg(offset)
	} else {
		cpu.Regs[13] -= reg(offset)
	}
}

func (cpu *Cpu) opThumbB1(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbB2(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbB3(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbB4(op uint16) {
	// PUSH
	count := popcount16(op & 0x1FF)
	sp := uint32(cpu.Regs[13])
	sp -= uint32(count * 4)
	cpu.Regs[13] = reg(sp)
	if (op>>0)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[0]))
		sp += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[1]))
		sp += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[2]))
		sp += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[3]))
		sp += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[4]))
		sp += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[5]))
		sp += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[6]))
		sp += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[7]))
		sp += 4
	}
	if (op>>8)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[14]))
		sp += 4
	}
}

func (cpu *Cpu) opThumbB5(op uint16) {
	// PUSH
	count := popcount16(op & 0x1FF)
	sp := uint32(cpu.Regs[13])
	sp -= uint32(count * 4)
	cpu.Regs[13] = reg(sp)
	if (op>>0)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[0]))
		sp += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[1]))
		sp += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[2]))
		sp += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[3]))
		sp += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[4]))
		sp += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[5]))
		sp += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[6]))
		sp += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[7]))
		sp += 4
	}
	if (op>>8)&1 != 0 {
		cpu.opWrite32(sp, uint32(cpu.Regs[14]))
		sp += 4
	}
}

func (cpu *Cpu) opThumbB6(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbB7(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbB8(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbB9(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbBA(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbBB(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbBC(op uint16) {
	// POP
	sp := uint32(cpu.Regs[13])
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>8)&1 != 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.pc = reg(cpu.opRead32(sp) &^ 1)
		case ARMv5:
			pc := reg(cpu.opRead32(sp))
			if pc&1 == 0 {
				cpu.Cpsr.SetT(false)
				cpu.pc = pc &^ 3
			} else {
				cpu.pc = pc &^ 1
			}
		default:
			panic("unimplemented arch-dependent behavior")
		}
		sp += 4
	}
	cpu.Regs[13] = reg(sp)
}

func (cpu *Cpu) opThumbBD(op uint16) {
	// POP
	sp := uint32(cpu.Regs[13])
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(sp))
		sp += 4
	}
	if (op>>8)&1 != 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.pc = reg(cpu.opRead32(sp) &^ 1)
		case ARMv5:
			pc := reg(cpu.opRead32(sp))
			if pc&1 == 0 {
				cpu.Cpsr.SetT(false)
				cpu.pc = pc &^ 3
			} else {
				cpu.pc = pc &^ 1
			}
		default:
			panic("unimplemented arch-dependent behavior")
		}
		sp += 4
	}
	cpu.Regs[13] = reg(sp)
}

func (cpu *Cpu) opThumbBE(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbBF(op uint16) {
	cpu.InvalidOpThumb(op, "not implemented")
}

func (cpu *Cpu) opThumbC0(op uint16) {
	// STM
	if op&(1<<0) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[0])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[0] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[0] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC1(op uint16) {
	// STM
	if op&(1<<1) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[1])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[1] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[1] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC2(op uint16) {
	// STM
	if op&(1<<2) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[2])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[2] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[2] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC3(op uint16) {
	// STM
	if op&(1<<3) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[3])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[3] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[3] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC4(op uint16) {
	// STM
	if op&(1<<4) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[4])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[4] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[4] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC5(op uint16) {
	// STM
	if op&(1<<5) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[5])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[5] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[5] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC6(op uint16) {
	// STM
	if op&(1<<6) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[6])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[6] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[6] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC7(op uint16) {
	// STM
	if op&(1<<7) != 0 {
		cpu.InvalidOpThumb(op, "unimplemented: base reg in register list in STM")
		return
	}
	ptr := uint32(cpu.Regs[7])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.opWrite32(ptr, uint32(cpu.Regs[15]))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[7] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[0]))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[1]))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[2]))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[3]))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[4]))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[5]))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[6]))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.opWrite32(ptr, uint32(cpu.Regs[7]))
		ptr += 4
	}
	if wb {
		cpu.Regs[7] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC8(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[0])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[0] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if wb {
		cpu.Regs[0] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbC9(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[1])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[1] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if wb {
		cpu.Regs[1] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbCA(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[2])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[2] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if wb {
		cpu.Regs[2] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbCB(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[3])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[3] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if wb {
		cpu.Regs[3] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbCC(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[4])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[4] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if wb {
		cpu.Regs[4] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbCD(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[5])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[5] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if wb {
		cpu.Regs[5] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbCE(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[6])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[6] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if wb {
		cpu.Regs[6] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbCF(op uint16) {
	// LDM
	ptr := uint32(cpu.Regs[7])
	if op&0xFF == 0 {
		switch cpu.arch {
		case ARMv4:
			cpu.Regs[15] = reg(cpu.opRead32(ptr))
			ptr += 0x40
		case ARMv5:
			ptr += 0x40
		default:
			panic("unimplemented arch-dependent behavior")
		}
		cpu.Regs[7] = reg(ptr)
		return
	}
	wb := true
	if (op>>0)&1 != 0 {
		cpu.Regs[0] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>1)&1 != 0 {
		cpu.Regs[1] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>2)&1 != 0 {
		cpu.Regs[2] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>3)&1 != 0 {
		cpu.Regs[3] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>4)&1 != 0 {
		cpu.Regs[4] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>5)&1 != 0 {
		cpu.Regs[5] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>6)&1 != 0 {
		cpu.Regs[6] = reg(cpu.opRead32(ptr))
		ptr += 4
	}
	if (op>>7)&1 != 0 {
		cpu.Regs[7] = reg(cpu.opRead32(ptr))
		wb = false
		ptr += 4
	}
	if wb {
		cpu.Regs[7] = reg(ptr)
	}
}

func (cpu *Cpu) opThumbD0(op uint16) {
	// BEQ
	if cpu.Cpsr.Z() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD1(op uint16) {
	// BNE
	if !cpu.Cpsr.Z() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD2(op uint16) {
	// BCS/BHS
	if cpu.Cpsr.C() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD3(op uint16) {
	// BCC/BLO
	if !cpu.Cpsr.C() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD4(op uint16) {
	// BMI
	if cpu.Cpsr.N() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD5(op uint16) {
	// BPL
	if !cpu.Cpsr.N() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD6(op uint16) {
	// BVS
	if cpu.Cpsr.V() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD7(op uint16) {
	// BVC
	if !cpu.Cpsr.V() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD8(op uint16) {
	// BHI
	if cpu.Cpsr.C() && !cpu.Cpsr.Z() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbD9(op uint16) {
	// BLS
	if !cpu.Cpsr.C() || cpu.Cpsr.Z() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbDA(op uint16) {
	// BGE
	if cpu.Cpsr.N() == cpu.Cpsr.V() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbDB(op uint16) {
	// BLT
	if cpu.Cpsr.N() != cpu.Cpsr.V() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbDC(op uint16) {
	// BGT
	if !cpu.Cpsr.Z() && cpu.Cpsr.N() == cpu.Cpsr.V() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbDD(op uint16) {
	// BLE
	if cpu.Cpsr.Z() || cpu.Cpsr.N() != cpu.Cpsr.V() {
		offset := int8(uint8(op & 0xFF))
		offset32 := int32(offset) * 2
		cpu.pc = cpu.Regs[15] + reg(offset32)
	}
}

func (cpu *Cpu) opThumbDE(op uint16) {
	// B undefined
	cpu.InvalidOpThumb(op, "invalid F16 with opcode==14")
}

func (cpu *Cpu) opThumbDF(op uint16) {
	// SWI
	cpu.Exception(ExceptionSwi)
}

func (cpu *Cpu) opThumbE0(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE1(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE2(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE3(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE4(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE5(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE6(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE7(op uint16) {
	// B
	cpu.pc = cpu.Regs[15] + reg(int32(int16(op<<5)>>4))
}

func (cpu *Cpu) opThumbE8(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbE9(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbEA(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbEB(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbEC(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbED(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbEE(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbEF(op uint16) {
	// BLX step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
	cpu.pc &^= 2
	cpu.Cpsr.SetT(false)
}

func (cpu *Cpu) opThumbF0(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF1(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF2(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF3(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF4(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF5(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF6(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF7(op uint16) {
	// BL/BLX step 1
	cpu.Regs[14] = cpu.Regs[15] + reg(int32(uint32(op&0x7FF)<<23)>>11)
}

func (cpu *Cpu) opThumbF8(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbF9(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbFA(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbFB(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbFC(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbFD(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbFE(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbFF(op uint16) {
	// BL step 2
	cpu.pc = cpu.Regs[14] + reg((op&0x7FF)<<1)
	cpu.Regs[14] = (cpu.Regs[15] - 2) | 1
}

func (cpu *Cpu) opThumbAlu00(op uint16) {
	// AND
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd & rs
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu01(op uint16) {
	// EOR
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd ^ rs
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu02(op uint16) {
	// LSL
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	rot := (rs & 0xFF)
	if rot != 0 {
		cpu.Cpsr.SetC(rd&(1<<(32-rot)) != 0)
	}
	res := rd << rot
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu03(op uint16) {
	// LSR
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	rot := (rs & 0xFF)
	if rot != 0 {
		cpu.Cpsr.SetC(rd&(1<<(rot-1)) != 0)
	}
	res := rd >> rot
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu04(op uint16) {
	// ASR
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	rot := (rs & 0xFF)
	if rot != 0 {
		cpu.Cpsr.SetC(rd&(1<<(rot-1)) != 0)
	}
	res := uint32(int32(rd) >> rot)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu05(op uint16) {
	// ADC
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	cf := cpu.Cpsr.CB()
	res := rd + rs
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, rs, res)
	res += cf
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu06(op uint16) {
	// SBC
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	cf := cpu.Cpsr.CB()
	res := rd - rs
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, rs, res)
	res += cf - 1
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu07(op uint16) {
	// ROR
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	rot := (rs & 0xFF)
	if rot != 0 {
		cpu.Cpsr.SetC(rd&(1<<(rot-1)) != 0)
	}
	rot = (rs & 0x1F)
	res := (rd >> rot) | (rd << (32 - rot))
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu08(op uint16) {
	// TST
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd & rs
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumbAlu09(op uint16) {
	// NEG
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	res := 0 - rs
	cpu.Cpsr.SetC(true)
	cpu.Cpsr.SetVSub(0, rs, res)
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu0A(op uint16) {
	// CMP
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd - rs
	cpu.Cpsr.SetC(res <= rd)
	cpu.Cpsr.SetVSub(rd, rs, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumbAlu0B(op uint16) {
	// CMN
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd + rs
	cpu.Cpsr.SetC(res < rd)
	cpu.Cpsr.SetVAdd(rd, rs, res)
	cpu.Cpsr.SetNZ(res)
}

func (cpu *Cpu) opThumbAlu0C(op uint16) {
	// ORR
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd | rs
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu0D(op uint16) {
	// MUL
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd * rs
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu0E(op uint16) {
	// BIC
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	rd := uint32(cpu.Regs[rdx])
	res := rd &^ rs
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}

func (cpu *Cpu) opThumbAlu0F(op uint16) {
	// MVN
	rsx := (op >> 3) & 0x7
	rs := uint32(cpu.Regs[rsx])
	rdx := op & 0x7
	res := ^rs
	cpu.Cpsr.SetNZ(res)
	cpu.Regs[rdx] = reg(res)
}
