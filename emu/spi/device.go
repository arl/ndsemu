package spi

type ReqStatus int

const (
	ReqFinish ReqStatus = iota
	ReqContinue
)

type Device interface {
	// Begin a SPI transfer. This is called when the master
	// (the ARM cpu) beings a SPI transfer with the device
	// by triggering the CS line.
	// This can be used to clean up internal data structures
	// and prepare for the transfer.
	SpiBegin()

	// Execute the SPI transfer logic. This function is called
	// any time the ARM CPU writes a new full-byte to the SPI,
	// and must return the reply generated by the device.
	//
	// This interface aims to provide support for master/slave
	// protocols, where the master (CPU) sends a "request",
	// and the slave (the device) sends back a "reply". Both
	// requests and replies can be made of multiple bytes,
	// so we provide support for this.
	//
	// The data slice is the current request. When the transfer
	// begins, this is made by just one byte (the first being
	// written). SpiTransfer() must process it and return:
	//
	//  * optionally, a slice containing a reply. The reply can
	//    be one or multiple bytes, that are sent back to the
	//    ARM CPU in the specified order. If reply is nil,
	//    0s are sent back.
	//
	//  * a request status that signals whether the current request
	//    is finished (SpiReqFinish), or it is still being processed
	//    (SpiReqContinue). If it's still being processed, the next
	//    byte written by the CPU will be appended to the current
	//    request, and SpiTransfer() will be called with a longer
	//    slice representing the full request.
	//
	// The stat return value can thus be used by the spi.Device to
	// manage multi-byte requests; until a request is complete,
	// SpiTransfer can return SpiContinue, and in any subsequent
	// call SpiTransfer will see the full request being formed
	// (with a growing request slice at each call). While the
	// request is forming, there is probably no reply, so "nil"
	// can be returned as reply (and zeroes will be transferred).
	//
	// When the request is finished, the spi.Device can build the
	// reply and return it. The reply will be cached and sends
	// back the CPU one byte at a time. Notice that SpiTransfer
	// is *NOT* called while a multi-byte reply is being sent;
	// writes from the CPU are basically ignored.
	//
	//
	// Important note on the SPI protocol design
	//
	// The SPI bus has a particular design: for each written
	// byte from the master, a byte is always read back from the
	// device. The two transfers (write and read) happen
	// simultaneously (bit by bit), so, barring out weird bit-level
	// protocols, the read-during-the-write cannot be a reply to
	// the write itself. At the register level, this is simplified
	// like so: the CPU first writes the byte to the SpiData reg;
	// the hardware then triggers the transfer; when the transfer
	// is finished, the CPU reads back from SpiData the
	// byte that was read during the transfer.
	// Now, many protocols are normal master/slave protocols:
	// the CPU write a command (eg: "read status"), and the device
	// replies (eg: "my status is 0x12"). To keep the logic of
	// SpiTransfer() easier to implement, the replied value is
	// delayed by one byte: for instance, if
	// the device generates a reply for the first byte (data[0]),
	// reply[0] is sent to the ARM CPU only after (= while) data[1]
	// is being written.
	SpiTransfer(request []byte) (reply []byte, stat ReqStatus)

	// End a SPI transfer. This is called when the SPI transfer
	// is finished, that is, when the CS line goes low. This can
	// be used to clean up internal structures, flushing for
	// partial state.
	SpiEnd()
}
